function nodeIDs = findSpecialBoundaryNodes(GRID, layerNodeIDs, lineCoords, refPoint, dx, m, normalDirection)
%% findSpecialBoundaryNodes.m
% Title          : Special boundary node finder (based on reference point)
% Author         : Przemysław Nosal
% ORCID          : 0000-0001-9751-0071
% Affiliation    : AGH University of Krakow
% Contact        : pnosal@agh.edu.pl
% Date           : 2025-04-28
% Version        : 2.0
% Description    : 
%   Identifies a special node exactly on the boundary line (based on 
%   given reference coordinates) and its neighboring nodes shifted along 
%   the outward normal. Pure grid-based search (no tolerance).
%   Designed for precise boundary condition application in Peridynamics.
% Dependencies   : GRID structure generated by gridGenerator.m
% License        : CC-BY 4.0
%
% -------------------------------------------------------------------------
% INPUTS:
% GRID           – node matrix [nodeID, x, y, (z), mass_factor]
% layerNodeIDs   – node IDs selected by findBoundaryLayerNodes
% lineCoords     – line segment coordinates [x1, y1, x2, y2]
% refPoint       – reference point lying on the line [x_ref, y_ref]
% dx             – grid spacing [mm]
% normalDirection– side of the normal (+1: right, -1: left)
%
% OUTPUTS:
% nodeIDs        – column vector [referenceNodeID; lowerNodeID; upperNodeID]
%
% LOCAL VARIABLES:
% tangent, normal – normalized vectors of the line segment
% lowerTarget     – coordinates shifted by -dx along normal
% upperTarget     – coordinates shifted by +dx along normal
% -------------------------------------------------------------------------

    % Extract line properties
    x1 = lineCoords(1); y1 = lineCoords(2);
    x2 = lineCoords(3); y2 = lineCoords(4);
    tangent = [x2 - x1; y2 - y1];
    tangent = tangent / norm(tangent);
    normal = normalDirection * [0 -1; 1 0] * tangent;

    coords = GRID(layerNodeIDs,2:3);

    % Find reference node
    R = coords - refPoint;
    t_proj = dot(R, repmat(tangent,1,size(R,1))', 2); % project along tangent
    n_proj = dot(R, repmat(normal,1,size(R,1))', 2);  % project along normal

    % Select nodes very close to refPoint along tangent
    tol_tangent = dx/2; % allow small misalignment
    close_tangent = abs(t_proj) <= tol_tangent;

    % Among those, find node closest in normal direction (0 shift)
    [~, idx_ref] = min(abs(n_proj(close_tangent)));
    ref_candidates = layerNodeIDs(close_tangent);
    refNodeID = ref_candidates(idx_ref);

    % Initialize output
    nodeIDs = refNodeID; % first node is ref

    % Find points shifted ±k*dx along normal
    for k = 1:m
        % Lower
        target_n_lower = -k * dx;
        [~, idx_lower] = min(abs(n_proj(close_tangent) - target_n_lower));
        lowerNodeID = ref_candidates(idx_lower);

        % Upper
        target_n_upper = +k * dx;
        [~, idx_upper] = min(abs(n_proj(close_tangent) - target_n_upper));
        upperNodeID = ref_candidates(idx_upper);

        nodeIDs = [nodeIDs; lowerNodeID; upperNodeID];
    end

    % Sort by normal distance (optional)
    nodeIDs = unique(nodeIDs, 'stable');
end
